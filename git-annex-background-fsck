#!/usr/bin/env python
import datetime
import os
import sys
import subprocess
import sqlite3
import time

now = datetime.datetime.now

def is_annex_root(path):
    return os.path.exists(os.path.join(path, ".git", "annex"))

def find_annex_root(root):
    path = root
    while path != "/":
        if is_annex_root(path):
            return path
        path = os.path.normpath(os.path.join(path, ".."))
    raise Exception("Could not find annex root for %s" % root)

def tree(path):
    if os.path.isfile(path):
        yield path
        return
    for root, dirs, files in os.walk(path):
        for f in files:
            fn = os.path.join(root, f)
            yield fn

def filtered_tree(path):
    for fn in tree(path):
        if '.git/' not in fn:
            yield fn

def get_all_files(paths):
    files = []
    for path in paths:
        annex_root = find_annex_root(path)
        for fn in filtered_tree(path):
            #TODO: it would be nice to prefix this with the name of the annex
            normalized = os.path.relpath(fn, annex_root)
            keypath = os.path.realpath(fn)
            keypath = os.path.relpath(keypath, annex_root).replace(".git/annex/objects","")
            files.append(dict(root=annex_root, full=fn, normalized=normalized, key=keypath))
            
    return files

def fsck(entry):
    os.chdir(entry['root'])
    status = subprocess.call(["git", "annex", "fsck", "-q", entry['normalized']])
    return status == 0

def connect_db(db_path):
    c = sqlite3.connect(db_path)
    try :
        c.execute('''CREATE TABLE fsck
                 (date text, filename text unique)''')
    except sqlite3.OperationalError:
        pass
    return c

def record_fsck(db, entry):
    try :
        db.execute('INSERT INTO fsck (date, filename) VALUES (?,?)', (now(), entry['key']))
    except sqlite3.IntegrityError:
        db.execute('UPDATE fsck set date=? where filename=?', (now(), entry['key']))

def get_fsck_times(db):
    c = db.execute("SELECT filename, date FROM fsck")
    return c.fetchall()

def run(db_path, annex_paths):
    annex_paths = map(os.path.abspath, annex_paths)
    annex_paths = map(os.path.realpath, annex_paths)
    last_commit = 0
    db = connect_db(db_path)
    fsck_times = dict(get_fsck_times(db))

    file_list = get_all_files(annex_paths)
    file_list.sort(key=lambda f: fsck_times.get(f['key'], 0))
    print len(file_list), "files"
    for f in file_list:
        if not os.path.exists(f['full']):
            continue
        last = fsck_times.get(f['key'])
        print "%s last fscked %s" % (f['normalized'], last or "Never")
        if fsck(f):
            record_fsck(db, f)

        if time.time() - last_commit > 10:
            db.commit()
            last_commit = time.time()

    db.commit()

if __name__ == "__main__":
    db_path = sys.argv[1]
    roots = sys.argv[2:]
    run(db_path, roots)
