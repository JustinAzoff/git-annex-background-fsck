#!/usr/bin/env python
import os
import stat
import sys
import time
import subprocess

def ts():
    return int(time.time())

def is_annex_root(path):
    return os.path.exists(os.path.join(path, ".git", "annex"))

def find_annex_root(root):
    path = root
    while path != "/":
        if is_annex_root(path):
            return path
        path = os.path.normpath(os.path.join(path, ".."))
    raise Exception("Could not find annex root for %s" % root)

def tree(path):
    if os.path.isfile(path):
        yield path
        return
    for root, dirs, files in os.walk(path):
        for f in files:
            fn = os.path.join(root, f)
            yield fn

def filtered_tree(path):
    for fn in tree(path):
        if '.git/' not in fn:
            yield fn

def get_all_files(paths):
    files = []
    for path in paths:
        annex_root = find_annex_root(path)
        for fn in filtered_tree(path):
            #TODO: it would be nice to prefix this with the name of the annex
            short = os.path.relpath(fn, annex_root)
            keypath = os.path.realpath(fn)
            parent = os.path.dirname(keypath)
            files.append(dict(root=annex_root, full=fn, short=short, key=keypath, parent=parent))
            
    return files

def fsck(entry):
    os.chdir(entry['root'])
    status = subprocess.call(["git", "annex", "fsck", "-q", entry['short']])
    return status == 0

def record_fsck(entry):
    parent = entry['parent']
    os.chmod(parent, os.stat(parent).st_mode | stat.S_ISVTX)
    t = ts()
    os.utime(parent, (t,t))

def is_sticky(entry):
    return os.stat(entry['parent']).st_mode & stat.S_ISVTX

def get_fsck_time(entry):
    try :
        if is_sticky(entry):
            return os.path.getmtime(entry['parent'])
    except OSError:
        pass

    return None

def run(annex_paths):
    annex_paths = map(os.path.abspath, annex_paths)
    annex_paths = map(os.path.realpath, annex_paths)

    file_list = get_all_files(annex_paths)
    real_files = [f for f in file_list if os.path.exists(f['full'])]
    fsck_times = [(get_fsck_time(f),f) for f in real_files]
    fsck_times.sort()
    print len(fsck_times), "files"
    for fsck_time, f in fsck_times:
        print "%s last fscked %s" % (f['short'], fsck_time and time.ctime(fsck_time) or "Never")
        if fsck(f):
            record_fsck(f)

if __name__ == "__main__":
    roots = sys.argv[1:]
    run(roots)
